# my solution
import math

def solution(w,h):
    m, n = max(w, h), min(w, h)
    s_per_line = math.ceil(m / n)
    return (w * h) - (s_per_line * n)
# Status: Wrong Answer
# Note: 20이내에서의 수를 입력하면 전부 정답이 나오는데 실패하는 tc가 꽤나 많다.
# 포럼에 보면 같은 상황인 사람들이 몇몇 보이는데 [499, 27] 같은 경우에 답이 틀리게 나온다고 한다.
# 격자를 직접 그려서 세볼 수도 없고.. 이론상으로 문제가 없는 것 같은데 어떤 부분에서 틀린건지 궁금하다.


# solution(내가 푼거 아님)
def solution(w, h):
    m, n = max(w, h), min(w, h)
    r = m % n
    while 0 < r:
        n, r = r, n % r

    gcd = n
    return w * h - (w + h - gcd)
# Status: Accpeted
# Intuition: 가로세로에 상관없이 선을 하나 넘을 때마다 못쓰는 사각형이 한 개 늘어난다는 점이 포인트
#            또한 최대공약수와도 관계가 있다.
#            w, h를 최대 공약수로 나눈 w', h'(서로소)의 격자를 생각할 때 (간단하게 2 * 3 을 생각하면 된다) 대각선은 (w' - 1) + (h' - 1) 개의 선을 지나게 된다.
#            따라서 버리는 사각형의 개수는 (w' - 1) + (h' - 1) + 1 = w' + h' - 1 이므로 다시 최대공약수를 곱해주면 전체 사각형에서 버리는 사각형의 개수는 w + h - gcd
#            이걸 서로소로 만든 뒤 계산해야 하는 이유는 서로소가 아닐 경우(=공약수가 있을 경우) 공약수 지점에서 가로선과 세로선의 교차점을 지나가기 때문이다. 
#            선을 두 개 지나가는 셈인데도 늘어나는 사각형은 한개가 되니 최대공약수로 나누지 않고 연산하면 오류가 남
#            최대 공약수의 경우 유클리드 호제법으로 구한다: lev1_최대공약수와최소공배수 참고
