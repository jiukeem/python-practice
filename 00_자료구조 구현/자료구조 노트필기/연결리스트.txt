-----------연결리스트(linked list)-----------
* 연결리스트는 파이썬으로 클래스를 구현하면서 공부했기 때문에 노트 필기는 별로 없다. 연결리스트 구현 파일을 참조

연결리스트도 데이터를 순서대로 저장하며 요소를 계속 추가할 수 있다. 

노드는 데이터와 링크(포인터, next)로 이루어져있음. 보통은 .next메소드를 통해 구현. node1.next = node2 로 설정을 해줬다면 node1.next는 node2에 대한 레퍼런스가 된다고 말할 수 있다. 노드들은 배열과 달리 메모리에 물리적으로 연속되게 저장되지 않는다. 각각 독립적으로 존재하지만 다음 노드에 대한 레퍼런스를 지니기 때문에 다음 노드가 어디 저장되어 있는지 알 수 있다. 첫번째 노드를 head라고 한다. 

-링크드 리스트의 접근 연산은 비효율적이다. 배열에서는 인덱스 주소를 계산해서 O(1)에 접근할 수 있었지만 얘는 head에서 시작해서 원하는 인덱스 횟수만큼 next로 이동해야하기 때문. 시간복잡도는 O(n)

-탐색(인덱스가 아닌 값으로 찾는 것)의 경우도 배열과 마찬가지로 선형 탐색을 사용한다. 시간복잡도는 O(n)

-삽입 연산과 삭제 연산은 해당 노드 앞뒤의 레퍼런스만 변경해주면 되기 때문에 O(1)이지만 사실상 previous node까지 접근한 다음에야 삽입/삭제 연산을 수행할 수 있으므로 O(n)이라고 보는게 맞다

-특수한 경우인 맨앞과 맨뒤일 때 : 맨앞은 삽입, 삭제 모두 O(1)이다. head노드는 한번에 접근할 수 있음. tail도 똑같을거라는 생각이 들지만 조금 다르다. 만약 삽입일 경우(=append) tail노드를 가져와서 링크를 이어주면 되기 때문에 O(1)이지만 마지막을 삭제하는 경우 마지막의 앞 노드(맨끝에서 두번째 노드)에 접근해야하기 때문에 O(n)이다. 이건 지금 singly linked list여서 그렇고 double linked list를 사용하면 이 부분은 O(1)로 개선할 수 있을 것 같다. 정리하자면 맨 앞에 삽입, 삭제는 O(1) 맨 뒤 삽입도 O(1), 맨 뒤 삭제만 O(n)

지금까지 본, 노드가 다음 노드의 레퍼런스만 가지고 있는 연결리스트를 singly linked list라고 한다. 이와 달리 다음 노드뿐만 아니라 이전 노드의 레퍼런스까지 가지고 있는 연결리스트는 doubly linked list다. 싱글이 왼쪽이서 오른쪽으로만 향한다치면 얘는 쌍방향 화살표를 가지고 있는 격.

이중 연결리스트를 구현할 건데 우선 접근연산과 탐색연산은 단일 연결리스트와 동일하다. 접근연산의 경우 중간을 기준으로 인덱스가 앞부분인지 뒷부분인지 판단하에 접근하면 더 빠르지 않을까 생각했는데 그래봤자 n/2 이니 시간복잡도는 똑같다. 탐색연산도 마찬가지다. 양쪽끝에서부터 시작해서 동시에 선형탐색을 진행하면 더 빠르지 않을까 생각했는데 그것도 n/2다. 뭐 조금 빠르게 하기 위해 이런식으로 메소드 코드를 바꿔서 짤 수는 있겠지만 어쨌든 시간복잡도는 동일하다.

삭제 연산의 경우 단일 연결리스트와는 다르게 지우려는 노드의 앞노드(previous node)가 아닌 해당 노드를 파라미터로 넣는다. prev와 next를 둘 다 가지고 있어서 해당 노드만 있어도 previous node에 접근할 수 있기 때문

이중연결리스트의 head/tail 의 삽입 및 삭제는 전부 O(1)이다. 단일 연결리스트와는 tail삭제의 시간복잡도가 다르다. prev를 통해 뒤에서 앞으로 접근할 수 있기 때문

두 연결리스트의 추가적 공간을 살펴보자. 추가적 공간이란 자료구조가 사용하는 공간 중 실제 저장하려는 데이터를 제외한 정보가 저장되는 공간을 말한다. 노드의 링크(레퍼런스)가 차지하는 공간이 추가적 공간이 되겠지. 단일 연결리스트는 O(n)의 추가공간을 사용하고 이중 연결리스트는 O(2n) -> O(n) 공간을 사용한다. 공간복잡도는 같지만 실제로는 이중 연결리스트가 더 많이 사용한다고 보면 된다.