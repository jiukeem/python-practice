-------------해시테이블-------------

배열이나 연결리스트와는 달리 순서관계가 없다. key-value 데이터로, 파이썬의 딕셔너리를 생각하면 쉽다. 딕셔너리는 키로 호출하지 인덱스로 가져올 수 없는 것처럼. 그리고 하나의 key에는 무조건 하나의 value만 할당되어야함

direct access table
-key를 인덱스로 생각하고 저장하는 방법. 예시로 104호 지우, 1107호 지희, 207호 광호 이렇게 데이터가 있다면 가장 큰 key인 1107을 기준으로 배열 메모리를 확보한다. 그리고 104주소에 지우를 넣고 207주소 칸에 광호를 넣는다. 이렇게 하면 배열의 접근연산을 사용해서 O(1)에 접근할 수 있다. 근데 문제는 낭비되는 공간이 너무 많다는 것. 1107개의 칸을 확보했는데 그 중에 3개만 사용하고 있고 나머지는 그냥 버려지는 공간이 되어버린다. 또한 key가 순서를 따질 수 없는 데이터유형이면 불가능할듯? 어쨌든 이런식으로 배열인덱스를 key로 이용해서 저장하는 방식을 direct access table이라고 한다.

hash table
-direct access table은 시간은 효율적이지만 공간이 비효율적이다. 해시테이블은 그에 비해 시간과 공간 둘 다 효율적으로 사용할 수 있는 방식이다. 우선 이 방식은 해시함수를 사용하는데 해시함수는 임의의 길이를 갖는 데이터에 대해 고정된 길이의 데이터로 변환해준다. 즉 1, 32, 10007, 230659000 를 넣어도 내가 1-100범위로 설정했으면 해시함수를 통해 2, 45, 71, 12 이런식으로 나온다는거. 이 나온값을 인덱스로 사용한다. 그럼 내 키들의 범위가 어떻게 되든간에 내가 원하는 크기의 배열메모리를 설정할 수 있다. direct access table에 비해 어어엄청나게 공간을 효율적으로 사용한다. 추가로, direct access table에서는 인덱스와 키가 동일했기 때문에 value만 저장했지만 이제는 key와 인덱스가 같지 않기 때문에 71번 인덱스에 키인 10007과 value값을 같이 저장해준다. 이제 접근할 때는 key를 해시함수로 돌려서 인덱스를 알아내고 해당 인덱스에 접근해서 가져오면 된다.

*해시함수
-해시함수 복잡한가? 좀 더 찾아볼까... 일단 약간의 설명을 추가한다. 우선 한 해시테이블의 해시함수는 결정론적이어야한다 - 같은 키를 넣을 때 항상 같은 값을 return해야 올바른 인덱스 주소를 알 수 있다. 두번째, 결과 해시값이 고르게 나와야한다. 범위 내에 존재하는 숫자들이 나올 확률이 최대한 비슷해야 한다. 마지막, 빨라야 한다. 저장이든 접근이든 매번 해시함수를 써야한다. 느리면 해시 테이블도 비효율적일 수 밖에 없다. 아 해시 함수를 그렇게 어렵게 받아들이지 않아도 된다. 조건만 만족하면 여러가지 함수를 해시 함수로 쓸 수 있고 몇 개 구현해 봄

파이썬의 hash 함수
-파이썬에는 hash 함수가 내장되어 있는데, 위에서 배운 것과 조금 다르다. 특정 범위내의 자연수가 아니라, 아무 정수를 return한다. 이 함수는 파라미터로 다른 두개의 값을 넣었을 때 절대로! 같은 정수가 나오지 않는다. 즉 바코드처럼 모든 값이 다른 정수를 할당받는다. 그리고 불변 타입 자료형(int, float, str, tuple, boolean)은 전부 hash 함수에 적용가능하다. 그래서 숫자가 아니어도 key에 사용할 수 있는것! (리스트같은 자료형은 안됨) 

해시 테이블 충돌
-배우면서 궁금했던 점이 바로 나왔다. key들을 넣었는데 결과값으로 나오는 자연수 중 겹치는 경우가 있으면 어떡하지? 이렇게 이미 사용하고 있는 인덱스에 새로운 데이터(키, 벨류 쌍)를 저장해야하는 경우가 생겼을 때, 충돌(collision)이 일어났다고 말한다. 해시 테이블에서는 충돌을 잘 처리하는 것이 매우 중요하다. 여러가지 방법이 있는 듯 한데 우선 chaining 이라는 방법을 살펴보자
-chaining: 인덱스 안에 노드를 저장해서 연결리스트를 형성하는 방법이다. node로 키벨류쌍을 저장해주고(self.data 대신 self.key와 self.value) next 메소드를 통해 다음 키벨류로 연결해준다. 음.. 이러면 첫번째 노드만 해당 인덱스주소에 위치하고 나머지 노드들은 이 배열 안이 아닌 메모리 여기저기에 흩어져있는거겠지? 


이제 chaining을 사용하는 해시테이블의 주요 연산들을 알아보자. 일단 순서가 없기 때문에 접근 연산은 없고 크게 탐색, 삽입, 삭제 연산이 있다.

탐색 연산
-원하는 key에 해당하는 value를 찾는 연산. 먼저 키를 해시함수에 넣고 결과값을 통해 배열의 인덱스에 접근한다. 그럼 거기에 연결리스트가 있겠지. 연결리스트를 선형탐색하면서 원하는 key를 탐색한다. 시간복잡도를 생각해보면 해시함수계산O(1) + 배열인덱스접근O(1) + 연결리스트탐색O(m) *해시 테이블의 길이인 n이 아니라 연결리스트의 길이인 m! 
-> 정말 운이 안좋아서 모든 키벨류쌍이 한 인덱스에 저장됐다고 하면 m=n이므로 시간복잡도는 O(n) (왜 분할상환분석을 적용하지않지?)

삽입 연산
- 해시함수를 통해 키를 인덱스로 변환(O(1)) - 인덱스에접근(O(1)) - 인덱스에 있는 연결리스트를 선형탐색하면서 해당 key가 존재하는지 확인(하나의 키에 하나의 벨류만 있어야 함)(O(n)) - 키를 찾으면 .value 값을 변환(O(1)) or 탐색에 실패한다면 연결리스트 마지막에 append 해줌(O(1))
-> 시간복잡도는 O(n)

삭제 연간
- 특정 키에 해당하는 키벨류쌍을 지우는 연산. 해시함수로 인덱스 도출O(1) - 인덱스로 배열에 접근O(1) - 키에 해당하는 노드 탐색O(n) - 노드삭제O(1)
-> 시간복잡도는 O(n)

아! 분할 상환 분석에 관한 설명이 뒤에 나와있었네ㅋ.ㅋ append와 마찬가지로 해당 인덱스의 연결리스트에 모든 키벨류쌍이 들어있는 경우는 거어어어어의 없다. 그래서 일반적인 경우를 생각해보면 키벨류쌍의 개수 n 을 배열의 크기 m으로 나눠서 평균적으로 연결리스트에 n/m개가 들어있을거라고 추측할 수 있다. 그러면 시간복잡도는 O(n/m) 근데 여기서 한가지 가정이 나오는데, 보통 해시테이블의 배열 메모리를 잡을 때 키벨류쌍 개수보다 작게 설정하지는 않는다. 상식적으로 생각해도 그렇잖아? 그래서 일반적으로 m은 n과 유사하거나 그보다 조금 작거나 크다고 보면된다. 그래서 결론은 O(1)이라고 해도 된다는거~
-> 해시테이블의 삽입, 삭제, 탐색 연산은 최악의 경우 O(n)이고 분할 상환 분석, 즉 평균적으로는 O(1)이다. 
 























 