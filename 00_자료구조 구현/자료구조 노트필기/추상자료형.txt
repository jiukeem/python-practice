추상자료형

-기능과 구현을 구분해서 이해하고 넘어가자. 삽입 연산의 기능은 '원하는 인덱스에 새로운 데이터를 입력하는 것' 이다. 이건 해시테이블이든 배열이든, 연결리스트든 모두 똑같다. 하지만 구현은 달라진다. 구현은 저 기능을 어떻게 실행시킬것인가에 대한 내용이므로 자료구조의 종류에 따라 다를 수 밖에 없다. 

-추상화는 구현을 몰라도 기능만 알고 있으면 프로그래밍을 할 수 있게 해주는 개념이다. 클래스를 만들 때 insert라는 함수를 만들었는데, 이 함수의 기능이 무엇인지만 알면 함수가 어떻게 동작하는지 몰라도 사용할 수 있다. 구현을 몰라도 기능만 알면 사용할 수 있게 해주는 것을 '추상화를 했다' 라고 표현한다.

-자료구조를 추상화한 것을 추상 자료형(abstract data type)이라고 한다. 데이터를 어떻게 저장하고 어떻게 관리할지 신경쓰지 않아도 기능만으로 데이터를 다룰 수 있다. 예를 들어 파이썬에서 기본 자료형인 리스트. 우리는 append를 통해 요소를 계속 갖다붙일 수 있는데 이게 내부적으로는 어떤 과정을 통해서 처리가 되는지 모른다. 리스트는 데이터간의 순서 관계가 있으며 접근 , 탐색, 삽입, 삭제 연산을 할 수 있는 추상자료형이다. 우리는 다음의 기능을 필요로 할 때 리스트를 사용하며 저게 처리되는 방식은 추상자료형에 포함되지 않는다. 자료구조(앞에서 한 동적배열 같은 애들)는 저 기능들을 어떻게 구현할건지, 데이터가 순서관계를 어떤 방식으로 유지하는지 등 구현까지 한개로 묶어놓은 개념이다. 동적배열은 리스트의 모든 기능을 가지고 있는 자료구조이다. 즉, '리스트는 동적배열로 구현할 수 있다' 라고 표현할 수 있다. 물론 리스트를 구현하는 자료구조가 동적배열만 있는 건 아니다. 연결리스트를 써도 리스트의 기능들을 모두 구현할 수 있다. 이런 상황에서 어떤 자료구조를 써야할지는 여러가지를 따져본 뒤에 정하면 된다(어떤 기능을 많이 쓸건지, 주로 값을 앞에 추가할건지 삭제를 많이 할건지 등등) 구현까지 떠올려야하는 자료구조 말고 내가 원하는 기능을 먼저 생각할 수 있는 추상자료형을 사용하면 코드의 흐름에 집중할 수 있다. 매번 메모리까지 들어가서 이렇게저렇게요렇게 구현해야겠다 할 수는 없잖아
즉, 기능을 중점적으로 얘기하고 싶을 때, 코드의 흐름에 집중하고 구현에 집중할 필요가 없을 때는 추상 자료형을, 코드의 성능을 분석하거나 최적화시키고 싶을 떄는 자료구조를 중점적으로 생각하면 되겠다.


리스트
- 리스트는 데이터간 순서 관계를 유지해주는 대표적인 추상자료형으로, 접근, 탐색, 삽입, 삭제의 네가지 기능을 약속한다. 꼭 파이썬의 그 리스트! 를 말하는게 아니라 리스트라는 추상자료형이 그렇다는거다. 파이썬은 추상화가 많이 된 고수준 언어이다. 구현보다 기능에 집중할 수 있는 언어라는 얘기. 그래서 파이썬의 많은 자료형들이 추상자료형의 이름을 그대로 가지고 있는 경우가 많다. 어쨌든 우리는 파이썬을 쓸거니까 파이썬의 리스트를 보자. 우선 insert메소드로 삽입연산이 가능하다(원하는 위치와 데이터를 파라미터로 받음) 접근은 인덱스[]를 통해 할 수 있다. [] = 4 를 통해 데이터 수정까지 할 수 있다. 탐색은 in을 사용한다. 불린값으로 리턴됨. del을 통해 삭제까지 가능하다. 이런식으로 네가지 기능이 모두 가능하다. 우리는 이 리스트가 무엇을 할 수 있는지만 알고 사용하며 얘가 내부적으로 어떻게 작동하고 있는지는 전혀 몰라도 된다. 

-지금까지 배운 자료구조 중 리스트를 구현할 수 있는 자료구조는 동적배열과 연결리스트다. 이 두가지 자료구조형을 쓸 때 어떻게 다른지 살펴보자(연결리스트는 더블리로 사용) 일반적인 연산에서 동적배열은 접근연산이 O(1)이라는 특징이 있다. 그 외에는 동적배열과 이중연결리스트 둘 다 O(n)이 소요된다 (접근, 탐색, 삭제, 삽입) 특수한 경우인 맨앞/맨뒤의 삽입/삭제의 경우에는 이중연결리스트는 네가지 전부 O(1)이다. 반면 동적배열의 경우 맨앞을 삽입/삭제 하는 것은 O(n)이고 맨뒤만 O(1)이다. (분할 상환으로) 
즉, 두 개가 차이가 나는 부분은 접근(동적배열은 1 연결리스트는n)과 맨앞의 삽입삭제 연산이다(동적배열은 n 연결리스트는 1) 내가 접근을 많이 할거라면 동적배열을 사용하는게 좋을 것이고 데이터를 맨 앞에 계속 삽입해나갈거라면 연결리스트가 더 좋은 선택이다.

-파이썬의 리스트는 내부적으로 동적 배열 자료구조를 사용한다. 파이썬리스트의 각 연산들 시간복잡도는 동적 배열의 시간복잡도와 같음.


큐
-리스트와 마찬가지로 데이터 간의 순서 관계가 있는 추상자료형이다. 마트줄을 생각하면 되며, 첫번째 들어온 사람부터 나가며 새로운 사람이 줄을 설 때는 맨 뒤에만 선다. FIFO(first in first out) 큐가 약속하는 연산은 세가지인데(즉 이 세가지가 지켜져야 큐라고 할 수 있다는 얘기) 1. 맨 뒤에 데이터를 추가할 수 있어야하고 2. 맨 앞에 데이터를 삭제할 수 있어야 하고 3. 맨 앞에 데이터에 접근할 수 있어야한다. (데이터를 추가할 때 꼭 맨 뒤에에만 추가할 수 있는(맨 앞에나 중간에는 구조적으로 절대 추가할 수 없는) 자료구조가 아니라 맨 뒤에 추가할 수 있는 기능이 있어서 내가 그걸 사용할 수 있어야 한다-는 얘기)

-파이썬에서는 데크(deque - doubly ended queue)라는 자료형을 사용해서 큐를 쓸 수 있다. 이름에서 볼 수 있듯이 맨앞과 맨뒤에서 삽입 삭제를 할 수 있게 해주는 자료형이다. 그럼 우리는 맨 뒤에 추가 맨앞을 삭제하는 기능만 사용해서 큐를 쓸 수 있겠지 from collections import deque로 데크를 가져올 수 있다. * 지금 리스트는 파이썬의 자료형 이름 자체가 리스트라서 얘랑 좀 다르게 느껴질 수 있는데 똑같은거다. 파이썬의 리스트 자료형을 써서 리스트 추상자료형을 쓸 수 있는 것.

-큐는 동적배열과 연결리스트를 이용해 구현할 수 있다. 둘 다 데이터간 순서를 유지하고 세가지 기능을 수행할 수 있는 자료구조이므로. 두개를 비교해보면 맨앞 삭제 연산에서 동적배열이 O(n)으로 연결리스트O(1)보다 느리다. 나머지 맨뒤삽입과 맨앞접근은 둘 다 O(1)로 같음. 이러면 연결리스트를 사용하는게 더 좋겠다. 파이썬의 데크 자료형도 내부적으로는 이중연결리스트로 구현되어있다. 


스택
-스택도 큐, 리스트와 마찬가지로 데이터간의 순서 관계를 약속하는 추상자료형이다. 접시 쌓인걸 생각하면 된다. 올릴 때도 맨위(맨끝)에, 뺄때도 맨위만 뺄 수 있다. LIFO(last in first out) - 가장 마지막에 들어온 데이터가 가장 먼저 삭제된다는 얘기. 스택이 약속하는 연산은 세가지로, 맨뒤 데이터 추가, 맨뒤 데이터 삭제, 맨뒤 데이터 접근이다. 파이썬에서는 데크를 사용해서 스택을 구현할 수 있다. 데크는 맨끝/맨앞에 데이터를 삭제하고 삽입할 수 있는 자료형이기 때문에 입맛에 맞게 큐로도 스택으로도 활용할 수 있다. 

-스택도 동적배열과 연결리스트를 이용해서 구현할 수 있다. 맨뒤삭제, 맨뒤삽입, 맨뒤접근 연산에 대해 동적배열과 이중여결리스트모두 O(1)이다. (동적배열은 분할 상환 분석으로 따질 때) 파이썬의 데크는 이중연결리스트를 사용하고 파이썬의 리스트는 동적배열을 사용하기 때문에 스택을 구현할 때 데크를 쓰든 리스트를 쓰든 시간복잡도의 차이는 없다. 


딕셔너리(=맵)
- 키벨류쌍을 삽입과 키를 이용한 탐색 및 삭제 연산을 할 수 있는 추상자료형. 데이터의 순서관계는 없다. 파이썬의 딕셔너리 자료형을 통해 딕셔너리 추상자료형을 구현할 수 있다. 

-해시 테이블 자료구조를 통해 딕셔너리를 구현할 수 있다. 모든 기능을 구현할 수 있고 삽입, 탐색, 삭제 모두 시간복잡도 O(1)에 해결할 수 있다. 실제로 파이썬의 딕셔너리 자료형도 내부적으로 해시 테이블을 사용한다. 


세트
- 집합이라고 생각하면 된다. 순서관계를 약속하지 않으며 삽입,탐색,삭제가 가능한데 주의할 점은 중복 데이터를 허용하지 않는다는 것이다. 파이썬의 세트 자료형을 통해 추상 자료형 세트를 구현할 수 있다. 파이썬의 set은 add를 통해 데이터를 추가할 수 있다. 저장한 순서대로 저장되지 않는다. 똑같은 데이터를 또 저장하려고 하면 에러는 나지 않지만 추가되지 않은 것을 확인할 수 있다. in을 통해 탐색 가능. 불린으로 return한다. remove를 통해 삭제할 수 있다.(인덱스가 없으니 항상 데이터 값을 파라미터로 줘야함)

-세트는 보통 해시테이블을 사용해서 구현한다(꼭 그래야하는 것은 아님) 세트를 구현하는 경우는 벨류값 없이 처음부터 키만 저장해준다. 삽입, 탐색, 삭제 연산을 전부 O(1)에 할 수 있다. 