그래프

-그래프란, 연결데이터를 저장할 수 있는 자료구조. 연결 관계라는게 뭘까? 
-지금까지 배운 것 중 연결리스트/동적배열은 선형관계를 저장할 수 있고 트리는 계층관계를 저장할 수 있는 자료구조이다. 이것과 마찬가지로 그래프는 연결관계를 저장할 수 있다. 지하철 노선도가 가장 대표적인 연결관계망이다. 아니면 페이스북 친구관계 같은 사회연결망. 지하철 노선도를 통해 최단경로를 알아낼 수 있고 사회연결망을 통해 추천친구를 표시해줄수 있다. 

-그래프도 연결리스트나 이진탐색트리처럼 노드를 기본단위로 사용한다. 노드간의 관계를 엣지라고 한다. A노드와 B노드 간에 엣지가 있다는 것은 둘이 연결되어있다는 것. 그리고 이 엣지는 (A, B)엣지 혹은 (B, A)엣지라고 부른다.

- 두 노드가 이어져있을때(엣지가 있을 때) 두 노드가 인접해있다고 말한다.(물리적 거리와는 상관이 없음). 
- A노드와 C노드가 인접해있지는 않지만 둘 다 B노드에 연결되어 있을 때는 A-B-C 경로로 연결됐다 라고 말할 수 있다. 그리고 거쳐야하는 엣지의 수가 2개이기 때문에 거리는 2라고 할 수 있다. 인접하지 않은 노드 두개는 경로를 여러개 가질 수도 있고 한개만 가질 수도 있고 아예 안가질수도 있다. 이 중, 가장 거리가 짧은 경로를 최단경로라고 한다. 특정노드에서 여러노드를 거쳐 다시 자기자신으로 돌아오는 경로는 싸이클이라고 한다. 
- 한 노드가 갖고있는 엣지의 수를 차수라고 한다. 예를 들어 사회연결망에서는 차수가 그 노드의 친구수를 나타낸다.

방향그래프(directed graph)
-엣지는 방향을 가질 수 있다. 위에서 본건 양쪽으로 둘 다 가능한 그래프: undirected graph(무방향 그래프)라고 한다. 예를 들어 지웅과 동호 사이에 엣지가 있으면 '지웅은 동호의 친구'도 맞는 말이고 '동호는 지웅의 친구'도 맞는 말이다. 이런게 무방향 그래프다. 방향이 존재하는 엣지도 가능하다. 인스타그램 팔로우를 생각하면 쉽다. 동호가 지웅을 팔로우하고 있는경우 엣지는 동호에서 나와서 지웅으로 들어가며 (동호, 지웅)엣지라고 부른다. 바꿔서 부를 수 없음! 물론 쌍방향도 가능하다. 다만 엣지를 무방향으로 만들어버리는게 아니라 (지웅, 동호)엣지와 (동호, 지웅)엣지를 둘 다 만들어줘야함. 또한 방향 엣지인 경우 차수를 더 깐깐하게 따져야한다. 해당 노드에서 나가는 엣지(해당 노드가 팔로우하는 수)를 출력차수라고 하고, 해당 노드로 들어오는 엣지(내 팔로워 수)를 입력차수라고 한다.

가중치그래프(weighted graph)
- 엣지마다 가중치를 줄 수 있다. 공항들이 노드고 항공편이 있는 공항끼리 엣지로 이어준다면 항공시간을 각 엣지에 가중치로 줄 수 있겠지. 노드간의 연결관계를 좀 더 정확하게 나타낼 수 있다. 거리를 잴 때 엣지의 수가 아닌, 가중치가 적용된 엣지 값으로 따진다. 

-이처럼 엣지의 특성에 따라 방향그래프와 가중치그래프가 될 수 있다. 

-모든 노드들이 연결되어있어야하는 건 아니다. 연결리스트나 트리에서는 연결을 끊어버리면 걔는 그냥 사라져버리는 거나 마찬가지였는데 여기는 엣지가 한개도 없는 노드가 있는 것도 가능하다. 극단적으로 말해서 엣지가 하나도 없고 노드들만 둥둥 떠있는 그래프도 가능한 것.


그래프 구현: 노드구현과 엣지구현
노드구현
-그래프는 연결리스트의 head나 트리의 root처럼 특징적이고 시작점 역할을 하는 노드가 따로 없다. 그래서 모든 노드에 언제든지 바로 접근할 수 있도록 구현해야함. 이를 위해 동적배열이나 해시테이블을 이용한다. 동적배열(파이썬의 리스트)에 노드들을 모아놓는데 그러면 각 노드가 특정값(=인덱스)을 가지므로 원하는 노드에 접근할 수 있다. 인덱스를 알고있으면 노드에 접근연산은 O(1)이다. 해시테이블(파이썬의 딕셔너리)를 이용해서 노드의 값을 키로, 노드를 벨류로 지정하면 좀 더 직관적으로 접근할 수 있다. 인덱스가 아니라 데이터를 입력하면 바로 접근가능. O(1)으로 효율적이긴한데 키는 겹치면 안되는 점에 유의. 노드의 값 중 각각 고유의 값을 가지고 있는 애를 골라서 키로 써야한다(유저 노드라면 이름 대신 이메일을 키로 사용하는 등)
-이 처리까지 해주면 노드부분은 구현 완료

엣지구현: 인접행렬 or 인접리스트를 통해 구현
인접행렬 
- 인접은 두 개의 노드 사이에 엣지가 있다는 것을 의미하고 행렬은 내가 일반적으로 생각하는 2차원 매트릭스를 말한다. 인접행렬이란 노드들끼지 연결되어 있는지를 나타낸 매트릭스라고 보면된다. 노드들을 우선 리스트(동적배열)에 저장해준 후, row 인덱스와 컬럼들을 인덱스로 채운다. heatmap을 그릴 때처럼 구성해서 연결되어있으면 1, 연결되어있지않으면 0을 표시해준다. 자기자신과 만나는 대각선부분은 전부 0이고 무방향그래프인 경우는 대각선을 기준으로 대칭이고 방향그래프이면 대칭이 아니다. 이걸 인접행렬이라고 하고 노드간에 연결이 되어있는지 아닌지를 한눈에 확인할 수 있다. 만약 가중치가 있다면 1/0이 아니라 가중치로 나타내면 된다. 1번인덱스에서 3번인덱스로 향하는 엣지가 있는지 알고싶으면 adj_matrix[1][3]으로 호출해서 확인할 수 있다. 한 노드의 상태가 보고 싶으면 adj_matrix[i] 식으로 가져오면 되겠죵?
인접리스트
-이 방식은 위의 인접행렬을 한줄씩 쪼개서 각 노드들의 변수로 할당하는 느낌이다. (정확히 그렇진 않음) 즉, 노드 클래스에서 self.adjacent_stations = []를 추가해준다. 0, 1, 1 식으로 저장하진 않고 연결된 노드들만 저장해준다 [dict['교대'], dict['양재']] 이런 식으로. 무방향일 경우는 A의 변수에도 B를 넣고 B의 변수에도 A를 넣어줘야하는 반면, A -> B 인 방향 그래프면 A의 adjacent 리스트에만 B를 넣어주면 된다. B의 변수에는 영향을 끼치지 않는다. 만약 가중치그래프라면 리스트 안에 튜플 형태로 저장해주면 된다. (dict['강남'], 6) 요런식으로

그래프의 시간/공간 복잡도
-그래프는 n이 아닌 다른 변수로 표현한다. V를 노드의 개수(vertex), E를 엣지의 수로 생각해보자(원래는 모든 노드들의 집합 / 모든 엣지들의 집합을 의미하는 거고 개수랑은 좀 다르다고 하는데 점근 표기법에서는 그냥 간단히 그렇게 생각하자) 일단 V와 E의 관계를 보자. 방향그래프일 때 E는 최대 V^2개 일 수 있다. (무방향이면 반쪼개서 V^2 / 2) 어쨌든 E는 최악의 경우 V^2에 비례한다. 
-우선 노드를 저장하는 공간은 O(V)이다. 인정행렬을 사용할 경우 인접행렬이 차지하는 공간은 O(V^2)이다. 인접리스트인 경우 V개의 리스트가 있을거고 그 안에는 E개의 요소가 들어있다. (무방향이면 2E) 근데 V와 E 둘 중에 뭐가 더 큰지 알 수 없으므로 공간복잡도는 O(V+E)로 표기한다.
-두 노드가 연결됐는지 확인하는 데에 걸리는 시간은 인접행렬의 경우 인덱스로 불러오면 한번에 알 수 있으므로 O(1)이고 인접리스트의 경우는 해당 노드의 인접리스트를 탐색해야하므로 O(V)이다. (최악의 경우 이 노드가 나머지 노드들하고 전부 연결되어있으면 V-1개의 요소를 가지므로)
-한 노드에 연결된 모든 노드들을 알아내는데에 걸리는 시간은 인접행렬의 경우 해당 row를 살펴봐야하므로 언제나 V번 확인해야한다. 시간복잡도는 O(V). 인접리스트도 최악의 경우 V-1번 돌아야하기 때문에 O(V)이지만 평균적으로는 인접행렬보다 빠르다.

-즉, 두 노드의 연결을 확인하는 연산이 많으면 인접행렬이, 한 노드에 연결된 모든 노드를 가져오는 연산이 많으면 인접리스트가 좋다. 


그래프 탐색
-지금까지는 탐색이 특정 조건을 만족하는(=특정 값을 가지는) 요소를 찾는 것이었다. 그래프에서는 탐색의 의미가 좀 다르다. 그래프 탐색이란, 하나의 시작점 노드에서 연결된 노드들을 전부 찾는 것이다. (직접적으로 연결된 애들만 찾는게 아니라 경로가 있는 노드 전부!) 하나의 노드에서 연결되는 모든노드를 돌기 때문에 그래프 순회라고 부르기도 한다. 
- 그래프 탐색을 통해 알 수 있는 것 1. 기본적으로 시작노드와 연결되어있는지 알 수 있다. 2. 시작노드와의 최단경로를 구할 수 있다. 
-그래프 탐색 알고리즘은 각 노드들을 어떤 순서로 탐색하는지에 따라 다음 두가지로 나뉜다. Breadth First Search 와 Depth First Search

BFS(Breadth First Search)
-너비 우선 탐색. 즉 시작노드에서 연결된 노드탐색 - 그 노드들에서 연결된 노드탐색(시작노드로부터 엣지 2개) - 엣지3개 - 엣지 4개 - ... 식으로 탐색해나가는 방법이다. BFS를 위해서는 큐를 사용해야 한다. 우선 시작노드들 방문표시 후 큐에 넣는다. 큐에서 가장 앞 노드를 꺼내서 해당 노드에 인접한 노드들을 체크해준다. 만약 방문표시가 되어있는 노드면 지나가고 아니면 방문표시를 해준뒤 큐에 넣는다. 이걸 큐에 아무 노드도 남지 않을 때까지 반복한다. 흠 근데 방문표시는 어떻게 하는거지? 인접한 노드들을 조사할 때 방문했던 노드인지 아는 방법이 궁금하다. 아 구현할 때 보니까 self.visited 라는 변수를 추가해줬다. 

-BFS 알고리즘의 시간복잡도를 계산해보자. 우선 모든 노드들의 visited 변수를 False로 표시해주는 데에 V의 시간이 걸리므로 전처리에 O(V)가 걸린다. BFS는 visited가 True면 큐에 넣지 않고 큐에 넣은 값을 뺄 때 visited를 True로 변경하므로 큐에 들어가는 노드는 딱 한번만 큐에 들어간다. (아예 안들어가는 애들도 당연히 있겠고) 맨 앞의 데이터를 빼내는 데에는 O(1)이 걸리고(이중 연결리스트) 최대 V개의 노드들이 들어올 수 있으므로 큐에 노드를 넣고 빼는 데 걸리는 시간은 O(V)이다. 마지막으로, 큐에서 노드를 꺼낼 때마다 그 노드의 인접리스트를 살펴본다. 앞에서 봤듯이 V개의 노드의 인접리스트들에 들어있는 요소갯수의 총 합은 E이므로(무방향이면 2E) 시간복잡도는 O(E)이다. 전처리 + 큐에서 노드넣고빼기 + 인접한노드들을 살펴봄 하면 O(2V+E)므로 BFS의 시간복잡도는 O(V+E)가 된다.

DFS(Depth Fisrt Search)
-깊이 우선 탐색. 시작노드에서 연결된 노드 하나 선택 - 그 노드에 연결된 노드 하나 선택 - 이러면서 더이상 연결된 노드가 없을 때까지 쭉쭉 깊이 들어간다. 그리고 막히면 다시 거슬러 올라오면서 또 다른 엣지가 있는 노드를 탐색 그러면 그쪽 엣지로 다시 깊게 파고들고를 반복. BFS가 큐를 사용했다면 DFS는 스택을 사용한다. 얘도 스택에 아무것도 남지 않을 때까지 연산을 한다는 것은 똑같지만 조금 더 복잡하다. 우선 모든 노드의 visited를 0으로 설정한다. DFS는 방문/안방문이 아니라 중간 과정이 하나 더 있기 때문에 0(처음보는 노드), 1(스택에 들어가 있는 노드), 2(이미 방문한 노드)로 사용한다. 어쨌든 visited를 0으로 설정해서 전처리을 해주고 내가 파라미터로 넣는 시작 노드를 1로 바꾼 후 스택에 넣는다. (넣을 때 1로 바꾸고 뺄 때 2로 바꾼다.) 스택의 가장 위 노드를 꺼내서 2로 변경한뒤 걔의 인접노드를 돌면서 확인한다. 1이나 2면 지나치고(1일 수 있나? 있을 것 같다. 그러니 BFS와 다르게 1이라는 값이 따로있지. 똑같은 걸 두번추가하지 않게 아, 얘는 스택에 이미 추가되어있는애라서 이따가 확인할거에요 안넣으셔도 돼요- 하고 알려주는거지) 0이면 1로 바꿔주면서 스택에 추가해준다. 맨 마지막으로 들어온애를 먼저 탐색하기 때문에 한쪽 방향으로 파고들면서 점점점 깊게 들어갈 수 있다. 

-DFS 알고리즘의 시간복잡도. 전처리에는 BFS와 같이 O(V)가 걸린다. 스택에 노드를 넣고 빼는 데에는 O(1)이 걸리고 BFS의 큐와 마찬가지로 한번 들어왔던 노드는 다시 들어올 수 없으므로 O(V)이다. 스택에서 뺀 노드의 인접리스트를 살펴보는 것도 BFS와 같으므로 O(E) 다 더하면 O(2V+E)이므로 DFS의 시간복잡도는 O(V+E)이다.