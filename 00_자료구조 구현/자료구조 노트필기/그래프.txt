그래프

-그래프란, 연결데이터를 저장할 수 있는 자료구조. 연결 관계라는게 뭘까? 
-지금까지 배운 것 중 연결리스트/동적배열은 선형관계를 저장할 수 있고 트리는 계층관계를 저장할 수 있는 자료구조이다. 이것과 마찬가지로 그래프는 연결관계를 저장할 수 있다. 지하철 노선도가 가장 대표적인 연결관계망이다. 아니면 페이스북 친구관계 같은 사회연결망. 지하철 노선도를 통해 최단경로를 알아낼 수 있고 사회연결망을 통해 추천친구를 표시해줄수 있다. 

-그래프도 연결리스트나 이진탐색트리처럼 노드를 기본단위로 사용한다. 노드간의 관계를 엣지라고 한다. A노드와 B노드 간에 엣지가 있다는 것은 둘이 연결되어있다는 것. 그리고 이 엣지는 (A, B)엣지 혹은 (B, A)엣지라고 부른다.

- 두 노드가 이어져있을때(엣지가 있을 때) 두 노드가 인접해있다고 말한다.(물리적 거리와는 상관이 없음). 
- A노드와 C노드가 인접해있지는 않지만 둘 다 B노드에 연결되어 있을 때는 A-B-C 경로로 연결됐다 라고 말할 수 있다. 그리고 거쳐야하는 엣지의 수가 2개이기 때문에 거리는 2라고 할 수 있다. 인접하지 않은 노드 두개는 경로를 여러개 가질 수도 있고 한개만 가질 수도 있고 아예 안가질수도 있다. 이 중, 가장 거리가 짧은 경로를 최단경로라고 한다. 특정노드에서 여러노드를 거쳐 다시 자기자신으로 돌아오는 경로는 싸이클이라고 한다. 
- 한 노드가 갖고있는 엣지의 수를 차수라고 한다. 예를 들어 사회연결망에서는 차수가 그 노드의 친구수를 나타낸다.

방향그래프(directed graph)
-엣지는 방향을 가질 수 있다. 위에서 본건 양쪽으로 둘 다 가능한 그래프: undirected graph(무방향 그래프)라고 한다. 예를 들어 지웅과 동호 사이에 엣지가 있으면 '지웅은 동호의 친구'도 맞는 말이고 '동호는 지웅의 친구'도 맞는 말이다. 이런게 무방향 그래프다. 방향이 존재하는 엣지도 가능하다. 인스타그램 팔로우를 생각하면 쉽다. 동호가 지웅을 팔로우하고 있는경우 엣지는 동호에서 나와서 지웅으로 들어가며 (동호, 지웅)엣지라고 부른다. 바꿔서 부를 수 없음! 물론 쌍방향도 가능하다. 다만 엣지를 무방향으로 만들어버리는게 아니라 (지웅, 동호)엣지와 (동호, 지웅)엣지를 둘 다 만들어줘야함. 또한 방향 엣지인 경우 차수를 더 깐깐하게 따져야한다. 해당 노드에서 나가는 엣지(해당 노드가 팔로우하는 수)를 출력차수라고 하고, 해당 노드로 들어오는 엣지(내 팔로워 수)를 입력차수라고 한다.

가중치그래프(weighted graph)
- 엣지마다 가중치를 줄 수 있다. 공항들이 노드고 항공편이 있는 공항끼리 엣지로 이어준다면 항공시간을 각 엣지에 가중치로 줄 수 있겠지. 노드간의 연결관계를 좀 더 정확하게 나타낼 수 있다. 거리를 잴 때 엣지의 수가 아닌, 가중치가 적용된 엣지 값으로 따진다. 

-이처럼 엣지의 특성에 따라 방향그래프와 가중치그래프가 될 수 있다. 

-모든 노드들이 연결되어있어야하는 건 아니다. 연결리스트나 트리에서는 연결을 끊어버리면 걔는 그냥 사라져버리는 거나 마찬가지였는데 여기는 엣지가 한개도 없는 노드가 있는 것도 가능하다. 극단적으로 말해서 엣지가 하나도 없고 노드들만 둥둥 떠있는 그래프도 가능한 것.


그래프 구현: 노드구현과 엣지구현
노드구현
-그래프는 연결리스트의 head나 트리의 root처럼 특징적이고 시작점 역할을 하는 노드가 따로 없다. 그래서 모든 노드에 언제든지 바로 접근할 수 있도록 구현해야함. 이를 위해 동적배열이나 해시테이블을 이용한다. 동적배열(파이썬의 리스트)에 노드들을 모아놓는데 그러면 각 노드가 특정값(=인덱스)을 가지므로 원하는 노드에 접근할 수 있다. 인덱스를 알고있으면 노드에 접근연산은 O(1)이다. 해시테이블(파이썬의 딕셔너리)를 이용해서 노드의 값을 키로, 노드를 벨류로 지정하면 좀 더 직관적으로 접근할 수 있다. 인덱스가 아니라 데이터를 입력하면 바로 접근가능. O(1)으로 효율적이긴한데 키는 겹치면 안되는 점에 유의. 노드의 값 중 각각 고유의 값을 가지고 있는 애를 골라서 키로 써야한다(유저 노드라면 이름 대신 이메일을 키로 사용하는 등)
-이 처리까지 해주면 노드부분은 구현 완료

엣지구현: 인접행렬 or 인접리스트를 통해 구현
인접행렬 
- 인접은 두 개의 노드 사이에 엣지가 있다는 것을 의미하고 행렬은 내가 일반적으로 생각하는 2차원 매트릭스를 말한다. 인접행렬이란 노드들끼지 연결되어 있는지를 나타낸 매트릭스라고 보면된다. 노드들을 우선 리스트(동적배열)에 저장해준 후, row 인덱스와 컬럼들을 인덱스로 채운다. heatmap을 그릴 때처럼 구성해서 연결되어있으면 1, 연결되어있지않으면 0을 표시해준다. 자기자신과 만나는 대각선부분은 전부 0이고 무방향그래프인 경우는 대각선을 기준으로 대칭이고 방향그래프이면 대칭이 아니다. 이걸 인접행렬이라고 하고 노드간에 연결이 되어있는지 아닌지를 한눈에 확인할 수 있다. 만약 가중치가 있다면 1/0이 아니라 가중치로 나타내면 된다. 1번인덱스에서 3번인덱스로 향하는 엣지가 있는지 알고싶으면 adj_matrix[1][3]으로 호출해서 확인할 수 있다. 한 노드의 상태가 보고 싶으면 adj_matrix[i] 식으로 가져오면 되겠죵?
인접리스트
-이 방식은 위의 인접행렬을 한줄씩 쪼개서 각 노드들의 변수로 할당하는 느낌이다. (정확히 그렇진 않음) 즉, 노드 클래스에서 self.adjacent_stations = []를 추가해준다. 0, 1, 1 식으로 저장하진 않고 연결된 노드들만 저장해준다 [dict['교대'], dict['양재']] 이런 식으로. 무방향일 경우는 A의 변수에도 B를 넣고 B의 변수에도 A를 넣어줘야하는 반면, A -> B 인 방향 그래프면 A의 adjacent 리스트에만 B를 넣어주면 된다. B의 변수에는 영향을 끼치지 않는다. 만약 가중치그래프라면 리스트 안에 튜플 형태로 저장해주면 된다. (dict['강남'], 6) 요런식으로