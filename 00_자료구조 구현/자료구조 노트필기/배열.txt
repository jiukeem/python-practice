코드잇 자료구조
자료구조: 데이터를 효율적으로 저장하고 관리하기 위해 사용하는 구조

컴퓨터에 데이터가 저장되는 곳 1.스토리지 2.메모리
스토리지는 데이터가 영구적으로 저장되는 곳. 우리가 저장하는 음악, 파일, 사진, 영상 등등. 사용자가 직접 지우는게 아니면 사라지지 않음. 우리가 일반적으로 따지는 500기가의 저장공간, 2테라의 외장하드 같은게 요 스토리지를 의미함. 스토리지는 데이터를 저장하고 받아오는 데에 오래걸린다.(창고 같은 느낌) -> 정확히 언제 사용할지 모르는 파일들이 저장됨. 지금 바로 꺼내서 써야하는게 확실한 데이터를 여기에 저장하는 건 적합하지 않겠지
메모리는 데이터를 임시로 저장하는 곳. 워드 파일을 작성할 때 저장 버튼을 누르기 전까지는 이 내용들은 전부 메모리에 있는 상태. 컴퓨터가 꺼지면 그냥 날라가버린다. 메모리는 '임시로' 저장하기 때문. 저장을 누르면 메모리에서 스토리지로 복사된다(이동이 아니라 복사) 램이 이 메모리를 얘기하는 것임. 메모리는 스토리지에 비해 용량이 현저히 작고(8기가 vs 1테라) 대신 데이터를 빨리 저장하고 받아올 수 있다. 스토리지가 창고라면 메모리는 책상서랍ㅋ.ㅋ 귀엽당

저장된 영화를 본다고 할 때, 영화는 일단 스토리지에 저장되어 있다. 스토리지에서 바로 꺼내오려면 프레임이 끊길 수도 있겠지(데이터를 가져오는게 느리니까) 그래서 영화를 실행하면 스토리지에 있는 영화파일을 메모리로 복사한 뒤 메모리에서 꺼내온다. 영화를 끄면 메모리에 있던 영화파일은 다시 사라짐. 이런 방식으로 스토리지와 메모리가 상황에 맞게 활용된다! 

우리가 얘기하는 자료구조는 메모리에 관한 얘기이다. 메모리에서 자료를 효율적으로 관리하는 것에 대한 공부임!

RAM(random access memory)
메모리는 영화필름처럼 칸이 나뉘어진 띠라고 생각하면 된다('그래서 컴퓨터는 어떻게 동작하나요?' 에서의 내용과 이어진다.) 각 칸에 데이터를 저장할 수 있고, 칸은 고유의 주소를 가지고 있다. 현대 컴퓨터 시스템은 메모리 한칸에 1바이트의 데이터를 저장한다.

random acces라는 뜻은 저장위치를 알면 접근할 때 항상 일정한 시간이 걸린다는 얘기다. 어떤 주소의 칸이든 접근하는 데에 같은 시간이 걸림. 즉, 메모리에 저장한 데이터에 접근할 때 시간복잡도는 O(1)이다. 이 개념의 반대는 순차접근인데 우리가 어릴 때 봤던 VHS 비디오를 생각하면 된다. 뒷부분을 보고 싶으면 앞부터 빨리감기를 해서 그 지점까지 가야한다. 즉 뒤쪽에 위치한 데이터일수록 접근하는 데에 걸리는 시간이 늘어난다(O(n)) 

파이썬에서 x = 95일 때  정확히 말하자면 변수 x는 메모리에서 95가 저장된 칸의 주소를 가지고 있다. 변수를 사용하려고 할 때는 파이썬이 알아서 95를 가져오는 과정을 실행하기 때문에 x + 10 도 문제없이 실행할 수 있는 것. 이렇게 데이터에 접근하게 해주는 값을 레퍼런스라고 한다. 레퍼런스와 램의 주소가 조금 다른 개념이라고 하는데(주소가 아니더라도 데이터에 접근할 수 있게 해주는 정보를 전부 레퍼런스라고 한다고 함. 자료구조 과정에서는 굳이 구분해서 쓰지않고 혼용할 것임) 레퍼런스가 좀 더 추상적이고 포괄적인 개념이라고 보면 된다. 어쨌든 x에는 95가 담겨있지 않고 레퍼런스가 담겨있다.

a = 3 다음에 b = a 라고 지정하면 a와 b는 같은 메모리의 칸을 가리키게 된다(같은 레퍼런스를 가진다) id로 메모리 주소를 확인하면 같은 값이 출력된다. 이렇게 여러 변수가 같은 메모리를 가리키는 것을 aliasing 이라고 한다.



------------------------------배열------------------------------
파이썬에는 배열이라고 부르는 자료구조가 따로 없는데, 파이썬의 리스트가 C의 배열을 기반으로 만들어진 자료형이다. 물론 리스트와 C배열은 다름. 리스트가 append를 통해 데이터를 계속 추가할 수 있는 반면, C 배열은 크기가 고정되어 있고 데이터를 수정할 수는 있지만 삭제할 수는 없다. 리스트는 element들의 데이터 타입이 다 달라도 되는 반면, C 배열은 같은 타입의 데이터들만 담을 수 있다. 

C를 잠깐 보자
int numArray[4]; 
배열을 만들 때 정수를 4개담을거다-라고 함께 얘기해줬다. 메모리에서 사용할 공간을 미리 예약한 것.(정수는 4바이트이므로 총 16바이트를 예약함) 이 때, 16칸은 연속적이어야 함. 4개씩 메모리 4군데 아무데나~가 아니고 물리적으로 요 저장공간들이 붙어있어야 함
반면 파이썬의 리스트(똑같이 정수 4개인) [2, 3, 5, 7]은 그렇지 않아도 된다. 얘는 램에 값을 저장하는 대신, 레퍼런스 4개를 저장할거다. 이 방식의 이점은, 어차피 값을 저장하는게 아니기 때문에 자료들의 크기가 어떻게 되든 상관이 없다는 점이다. 아무리 큰/작은 값이든 다른 타입의 자료형이든 그냥 가리키는 레퍼런스만 저장되어 있기 때문에 다양한 타입의 값들을 리스트에 넣을 수 있는 것. C는 처음에 4바이트씩 총 16개 쓸거에요- 했으니까 나중에 요소 한개만 다른 데이터타입으로 바꿀 수가 없다. 걔는 정수가 아니라서 4바이트가 아닐테니까. 파이썬 리스트는 어차피 레퍼런스가 들어있으니까 레퍼런스 값 좀 바꿀게요~ 하면 되는 것.

배열에 데이터를 저장하고 가지고 오는 법(파이썬의 리스트와는 다른 부분이 있으니 C언어를 기준으로 보자)
배열 numArray는 배열이 시작되는 칸의 주소를 가지고 있다. 배열은 메모리에 연속적으로 저장되어 있으니 시작주소 + 데이터크기(정수형이라면 4) * 인덱스 i 를 해주면 내가 찾고자 하는 인덱스 값의 주소가 나온다. 물리적으로 연속적으로 저장되어 있기에 가능한 방법. 램은 임의접근방식이므로 주소만 알면 O(1)으로 접근가능하다. 결론적으로, 주소를 간단히 계산할 수 있고 주소를 알면 O(1)으로 접근이 가능하므로 배열에서 (인덱스를 통해) 데이터에 접근하는 방식은 O(1)이다. 값을 저장하는 것도 마찬가지다. 똑같이 인덱스의 주소를 계산하고 임의접근으로 딱 찾으면 O(1)이다.! 배열에서 인덱스 접근은 항상 O(1)이고 요게 배열의 가장 큰 특징 및 장점이다.

배열 탐색을 보자. 접근은 인덱스를 통한 접근이고 탐색은 인덱스를 모른 채로 내가 원하는 값을 찾는 것을 말한다. 간단히 생각해봐도 배열의 요소들을 하나하나 확인해야 할테므로 접근보다 훨씬 비효율적인 것을 알 수 있다. 순서대로 데이터들을 일일히 확인하는 방식을 선형탐색이라고 한다. 배열이 정렬되어있는게 아닌 이상 이 방법을 써야겠지. 배열 탐색의 시간복잡도는 O(n)

배열 접근 연산은 O(1) (인덱스 활용) 
배열 탐색 연산은 O(n) (인덱스는 모르고 value로만)

배열에는 정적배열과 동적배열(dynamic array)이 있다. 보통 아무설명 없이 배열이라고 하면 정적배열을 말함
정적배열은 처음 정의할 때 크기(요소수)를 제한하고 이 이상 요소를 추가할 수 없다. -> C배열
동적배열은 요소를 계속 추가할 수 있으며 그에 따라 크기가 계속 변한다. -> 이게 파이썬의 리스트? * 아닌듯. 확실하지 않음 아 맞음! 파이썬의 리스트가 동적배열 (그렇다고 씨언어에 동적배열이 없다는 게 아님)

일단 지금까지의 설명은 전부 정적배열에 관한거였고 동적배열에 관한 설명이라고 따로 언급한게 아니면 앞으로도 전부 정적배열에 대한 것임.

처음에 int numArray[4]; 로 배열을 생성하고 2, 3, 7, 9를 넣었는데 13을 더 넣고싶다면? 넣을 수 없다. 어쩔 수 없이 int numArray[5]를 만든 뒤에 기존의 배열 값들을 넣어주고 다섯번째 자리에 13을 넣어줘야 한다. 처음에 선언할 때 정수 4개가 들어갈 연속적인 자리만 확실히 확보해놓기 때문에 그 뒤, 13이 붙을 수 있는 자리가 비어있는지 이미 다른 용도로 찼는지 알 수 없기 때문. 그렇다고 처음부터 너무 넉넉하게 배열메모리를 할당하면 메모리가 비효율적으로 사용되겠지 채우지 않는다면 공간이 낭비됨.

이에 비해 동적배열은 어떻게 다른지 살펴보자. intDynamicArray(이게 C언어의 동적배열 변수인듯) 를 선언하면 4개가 꽉찼을 때 다섯번째 요소를 집어넣으려고 하면 얘가 알아서 원래 배열의 두배크기의 메모리를 다시 확보한다. (4개였으니 이번에는 8개) 그 다음에 기존 배열의 데이터들을 복사하고 내가 추가하려는 다섯번째 요소도 넣어준다. 그러면 3개의 빈공간이 남아있으니 더 추가할 수 있겠지. 만약 또 다 차버리면 다시 두배 크기의 (물리적으로 연속적인)메모리를 확보한다. 이런식으로 반복됨. 물론 2배씩 안늘어나도 상관은 없고 컴퓨터 언어마다 다 다르게 설정되어있다고 한다. 결국 동적배열도 내부적으로는 정적배열을 사용하며 꽉 찰 때마다 메모리를 다시 확보하는 단계가 내부에 구현되어 있는 것. 우리가 배열의 크기에 대해 신경써주지 않아도 되기 때문에 편리함. 파이썬의 리스트가 이 동적배열인데, 만약 우리가 리스트에 9개의 요소를 저장해놓더라도 배열의 크기로는 12개를 확보해놓고 있는 것일 수 있다. 근데 만약 그렇다해도 우리는 여기에는 접근하지 못함. len을 쓰면 요소의 개수가 나오지 배열의 크기가 나오지는 않으니까. 또한 list[10]으로 접근하려고 해도 에러가 남. 파이썬 뿐만 아니라 동적 배열을 자료형으로 제공하는 언어들은 우리가 값을 저장해 놓은 공간에만 접근할 수 있도록 처리가 되어있다고 한다.


-동적배열의 추가연산(append operation) 시간복잡도 -> 파이썬 list에서는 append 메소드
배열의 끝에 새 값을 추가하는 것을 append operation(추가 연산)이라고 한다. 동적배열에 값을 append할 때 시간복잡도를 계산해보자. 배열에 남는 공간이 있는 상태일 때는 인덱스를 통해 칸에 접근한 뒤 값을 넣어주면 되므로 O(1)이다. 배열이 꽉 찬 경우는 일단 지금 배열보다 두배로 큰 공간을 예약한다. 그런 다음 기존 배열의 값들을 복사해주고 마지막으로 새 값까지 빈칸에 추가한다. 각 칸에 접근할 때 마다 O(1)이 걸리므로 이 경우 시간복잡도는 O(n)이다. 이러면 사실 최악의 경우를 생각해서 O(n)이라고 해야겠지. 근데 O(n), 즉 배열이 꽉 찬 경우는 배열에 자리가 남아있는 경우보다 그 빈도수가 현저히 작을 것이다. 저 몇번 안되는 경우때문에 O(n)이야! 라고 해버리면 좀 불공평하지 않을까? 이렇게 최악의 경우로 시간복잡도를 산정하는게 이치에 맞지 않는 경우에는 다른 방식으로 시간복잡도를 산정할 수 있다. 그 중에 하나인 분할 상환 분석(Amortized Analysis)를 보자.

Amortized Analysis(분할 상환 분석): 같은 동작을 n번 했을 때 총 시간이 x이면 시간복잡도를 x/n이라고 산정하는 방식이다. 이런 방식으로 시간복잡도를 따지면 거의 발생하지 않는 O(n)은 시간복잡도에 영향을 덜 주게 되겠지. 처음 배열 크기를 1이고 계속 값을 추가해나간다고 할 때, 2, 4, 8, 16, 32.... 에서 O(n)이 걸릴 거고 나머지 경우는 O(1)일거다. n이 무한대로 갈수록 O(n)인 경우보다 O(1)인 경우가 압도적으로 많다. 그래서 분할 상환 분석으로 시간복잡도를 따지면 O(1)이라고 할 수 있다. 구글링으로 파이썬의 리스트 append 시간복잡도 를 찾아봐도 다 O(1)로 뜬다. 정말 정확하게 말하자면 '동적 배열의 추가(append) 연산은 최악의 경우 O(n)이 걸리지만, 분할 상환 분석을 하면 O(1)이 걸린다.'고 할 수 있다.

-동적배열의 삽입연산(insert operation) 시간복잡도
끝에 추가가 아니라 중간에 값을 삽입하고자 할 때는 시간복잡도가 어떻게 될까? 남는 공간이 있을 때는 기존의 애들을 뒤로 하나씩 밀어주고 넣으면 된다. 슬라이딩처럼 그냥 미는게 아니라 한칸씩 옮기면서 값을 새로 지정해주는 거기 때문에 시간복잡도는 O(n)이다. 배열이 다 찼을경우는 더 큰 메모리 확보 후 기존 요소들을 옮겨 저장하는데에 O(n), 그 다음에 새로운 값을 삽입하는 데에 O(n) 총 O(n)이다. (기존 요소를 옮길 때 동시에 새로운 값을 삽입하면서 그 뒤 인덱스는 하나씩 밀어서 저장해주는 건 안되나보다. 그래도 O(n)인건 똑같지마는) 결론은 두 경우 모두 O(n)이다. 맨 끝에 append는 O(1)이지만 insert는 O(n) 

-동적배열의 삭제연산 시간복잡도
삽입연산과 같다. 삭제할 것 기준으로 뒷 인덱스들에 접근해서(O(1)) 한개씩 직접 당겨 입력해주어야하므로(O(n)) 시간복잡도는 O(n)

-동적 배열 크기 줄이기
배열이 꽉 차면 더 큰 메모리를 확보해서 배열을 복사하는 것과 마찬가지로 배열에서 요소를 뺀다든지의 이유 등으로 남는 빈 공간이 너무 많아졌을 때는 반대로 작은메모리를 확보 후 이동한다. 이 기준 역시 프로그래밍 언어마다 다르며 1/2 1/3 등이라고 생각하면 된다. 1/2이라고 했을 때 8개짜리 배열의 요소가 4개이하로 떨어지면 4개짜리 배열을 다시 확보해서 옮기는데 이 과정은 O(n)이다. 

-위와 관련해서 동적 배열의 맨 끝 요소를 삭제하는 경우를 살펴보자. 대부분의 경우는 O(1)이지만 특정 경우에는 더 작은 메모리로 복사하는 과정이 일어나기 때문에 이 경우는 O(n)이다. append와 마찬가지로, 분할 상환 분석을 적용하면 O(1)이라고 할 수 있다. 

-지금까지 한 걸 정리해서 배열과 동적 배열을 비교해보자
배열과 동적배열 모두 access(through index)와 search(through value)에 각각 O(1), O(n)이 걸린다. 배열은 insert 및 delete가 불가능하다. 동적배열의 insert와 delete는 둘 다 O(n)이지만 마지막 요소인 경우, 즉 append와 pop은 분할 상환 분석을 통해 O(1)이라고 볼 수 있다. 
배열은 처음부터 딱 크기를 정해놓기 때문에 낭비되는 공간이 없다.(4개 지정해놓고 3개만 넣는 것도 안된다; 그럼 마지막 칸이 null 이 되는건데 이건 정수형이 아니니까 에러가 남) 반면 동적배열은 상황에 따라서 낭비되는 메모리가 생기기도, 없기도 한데 가장 낭비되는 공간이 많은 경우는 이제 막 더 큰 메모리로 옮겼을 때이다. n개짜리 메모리에 n+1번째 요소를 추가하려고 하면 메모리는 2n의 배열을 다시 확보한다. 여기에 n+1개의 칸만 사용하므로 낭비되는 메모리는 n-1이다. 즉 최악의 경우 낭비되는 공간은 O(n)이다.  
